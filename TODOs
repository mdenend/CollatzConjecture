1. Some better integer handling logic. Build a VisitedNumbers Wrapper class.
    (DONE) a. Build two VisitedNumbers maps:
        aa. one for ints less than int max
        ab. one for longs greater than int max.
    (DONE, except for mode 4.) b. When Computing the 3x+1 mapping on a number, always convert it to BigInteger. There should only be one BigInteger actively used in memory at any time,
            so this isn't expensive to do.
    (DONE) c. Build an add method into VisitedNumbers that takes a BigInteger as a parameter, and parses it into a long.
        aa. Should never be an issue with precision, since we won't be running numbers THAT big.
        ab. In this method, check if the number exceeds INT_MAX. If so, put into the long mapping. Otherwise, put into the int mapping.
    (DONE) d. Have VisitedNumbers tied to the option helper, always, but only trigger it if timeefficient flag is run (which is what the setup is anyways).
2. Changing mode 4:
    a. Helper: Shouldn't extend MultiBaseListSizeHelper. Actually, the Helper is pretty much the same as the AvoidingModGrowthHelper, isn't it?
        NAH. This is still different enough. I should do the following:
            aa. (DONE) Extend AvoidingModGrowthHelper from MultiBaseListSizeHelper. Also delete any unnecessary fields in AvoidingModGrowthHelper.
            ab. (SEE ad instead.)
            ac. (DONE) Pass in the mapping from Main to the method, so we can just leverage the EXACT same method for both modes.
            ad. (DONE) Actually have the MultiBaseListSizeHelper take in odd numbers as parameters, but throw an exception if type 0
                    helper calls this method.
            ae. (DONE) LargestNumber is an interesting enough piece of information that might be useful in other modes,
                    potentially. So actually move that method and the number to the ListSizeHelper class,
                    and call it in both mode 0 and 4.


    b. (DONE) EVENTUALLY: I'm going to want to merge MultiBaseListSizeHelper and AvoidingModGrowthHelper. They're basically identical at this point,
            only difference is that AvoidingModGrowthHelper is using odd numbers, and comparing Longs instead of Ints.
        aa. The Longs/Ints? That'll be handled by the better design decisions I've made in point 1.
        ab. All calculations in BigInts, but helper checks can store info in whatever format. It doesn't matter. The only bottleneck is VisitedNumbers.
    c. (DONE) Other than that, the flow for mode 0 and mode 4 are basically exactly the same, except for the very end.
        aa. In mode 0, we only store one chain record.
        ab. In mode 4, we store progressively growing chain records.
3. LAST THING: Test this. Make sure both mode 0 and 4 with visitedNumbers work for numbers up to 1 million, and rigorously test to make sure results make sense between the modes, and compare to previous outputs.
        THEN, after fixing any bugs, I can get Marijn the results he wanted, and hopefully efficiently run from 1 to 1 billion on Condor! (I might not have to split into slices either now that I've cut required memory in half...)
4. ONE OTHER THING: Fix the AvoidanceGrowthTable to output the correct hardness calculations.
