This is an application to run the 3x+1 problem. It allows us to run the 3x+1 problem on a batch system, like Condor, using a number of input files.

(Define "Chain here")

First, you need to compile this package. To do this, run:

 javac -d [YOUR_DIRECTORY_NAME] src/collatz/Main.java src/collatz/compute/* src/collatz/helpers/* src/collatz/output/* src/collatz/utils/*


Then, you need to generate input files that denote the number ranges. To do this, run:

       
    java -cp [DIRECTORY_WITH_GENERATED_INPUT_CLASS] GenerateInputFiles lowNum highNum numFiles

    lowNum: The lowest number that you run the 3x+1 problem on. Number must be positive. Allows any value up to 2^63-1. Should be odd.
    highNum: The highest number that you run the 3x+1 problem on. Number must be positive. Allows any value up to 2^63-1. Must be greater than lowNum. Also should be odd.
    numFiles: The number of input files that you'll divide into.

    GenerateInputFiles will figure out the slice size per number number range by computing highNum - lowNum, then divide by numberOfFiles.
    If the resulting slice size is an odd number, since our code is sensitive to odd/even numbers, it will terminate the code and not generate files.

    The resulting input files will always start with an odd number, and end with an even number. To make things best work, it's best to:
        1. Make both the input and output numbers are odd odd.
        2. Make the difference of them EXACTLY a power of 2. Ex: lowNum = 1; highNum = 2^32 + 1. The difference is 2^32.
        3. Make numFiles some power of 2. Good choices are 128 (less threads, less granularity), or 1024. Both of these will divide perfectly evenly into 2^n
        for any int n >= 10.

After this, you'll have some number of input files stored into the directory Input. (Note: in the future, have an option where we can change the input directory,
but I don't super care about this now.)

To run the 3x+1 problem, you need to run:

    java -cp [DIRECTORY_FOR_COLLATZ_PACKAGE] Main [--base baseNum] [--baseoutput ALL|EVEN|ODD|[#-#, #, #]] [--inputfile Input/InputLarge.txt] --timeefficient --outputfile Output/Large/outputtimeeff.csv 5 1 7 5-7


    --base #: Changes the base of our graph to #. If no input, default is 8.
    --inputFile name: take the input file and consider the range. Input file has two lines: one for the start number, and the other for the stop number.
    --baseOutput ALL, EVEN, ODD, [#-#,#] Changes the output bases.
        If ALL, bases from 2-32 are considered.
        If EVEN, only even bases from input are considered.
        If ODD,  only odd bases from input are considered.
        If single number, just consider that base.
        If brackets detected [] (or something else), then take any range low-high in hyphen, and other numbers in commas. Ex. [2-8, 12] means numbers from 2-8 and 12.
    --mode baseavoid|entirechain|untildecay|updown|avoidingmodgrowth Changes the various modes in which we can analyze the collatz conjecture:
      baseavoid is the default option. This allows us to check, for multiple bases, how long it takes for us to hit a base.

      entirechain just prints the entire chain, from the starting number to 1. Does not print 1, but it's trivial that 2 goes to 1, so this is unnecessary.

      untildecay means that, for an odd number, we continue to run until we have a number lower than the original number. We then check to see if the chain is longer than previous one.
      updown is a quite different mode. In a set of numbers, for each odd number, determine how long it can run until decay
         (EXACTLY the same as case 3, except we don't care about the list, just what number it becomes and number of steps), and
         what's the shortest length that a number below it can be, what's that number, and the number of steps (if we go backwards). So csv here is VERY different from other cases.

      avoidingmodgrowth is a mode that analyzes records of the given x mod b, where x is the node we're avoiding, and b is the base we're analyzing.
    --numSteps #: restricts the number of steps made in the Collatz Conjecture. Includes input number as a step. Must be greater than 1. Usually done with whole list mode.
    --onenumber # only run the Collatz Conjecture on this number.
    --outputFile name: outputs the text to name_avoidingBase#.csv, where # is/are the base(s) that this file corresponds to. If nothing, name will just default to output (with .csv suffix)
        Also splits at the last period and adds the avoid bases between the name and suffix.
    --reverselimit #: sets the maximum amount of steps we can reverse compute for the 4th mode, otherwise it may run infinitely. Only used in 4th mode, not anywhere else.
    --timeefficient uses a map to store numbers that were already detected in Collatz conjecture. Only a good idea if you have enough memory for RANGE/2 BigInts.

    Last numbers are the ones that are supposed that we're tracking. 1 means avoid 1 mod b (b is the base number, 2,3 means avoid both 2 mod b and 3 mod b.
    	 In the baseavoid mode, we can avoiding several bases as a group. Ex: 2-3 means avoid both 2 mod b and 3 mod b.


    Examples:

    Assume that, in our present working directory, that we have the following directories:
    out: has all of the compiled output, hence will be in -cp
    Input: has the input text file with the two numbers.
    Output/Batch1: where the output will go.

    baseavoid:
    java -cp out --inputfile Input/Input.txt Main --mode baseavoid --base 8 --baseoutput ALL --timeefficient --outputfile Output/Batch1/outputtimeeff.csv 1 5 7 5-7
        runs a test for all input numbers and for one input number, sees when the 3x+1 mapping chain hits 1 mod 8, 5 mod 8, 7 mod 8, and 5 mod 8 AND 7 mod 8 together, and tracks records for avoiding said bases.
        --inputfile grabs the file Input/Input.txt and reads the first number x as the start of the range, and the second number y as the end of the range.
        --mode baseavoid runs the 3x+1 mapping, for all odd numbers from range x to y, until these odd numbers reach 1. While a number n is being run,
        it is being tracked for
        --base 8 makes us avoid the numbers n (listed as the last arguments, here 5, 1, 7, and 5-7 together) mod 8.
        --baseoutput ALL means we output all bases from 2 to 32 in the output file.
        --timeefficient If this mode is enabled, when an odd number is visited in any chain, it is added to a "visited set". Before a new chain is built, if one of the input numbers between x and y is in this "visited set", we skip this number.
        --outputfile Output/Batch1/outputtimeeff.csv outputs several files for each of the record chains avoiding 1 mod 8, 5 mod 8, 7 mod 8, and 5 mod 8, 7 mod 8 together.
        1, 5, 7, 5-7 makes 1 mod 8, 5 mod 8, 7 mod 8, and 5 mod 8 + 7 mod 8 are the targets.