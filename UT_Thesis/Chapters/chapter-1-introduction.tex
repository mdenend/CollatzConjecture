\chapter{Introduction} \label{sec:introduction}
%Introduction: First sentence: Computers have been very powerful applications for many things, but they don't work for seemingingly simple problems.

%Second sentence: Does  there  exist  a  program  that  can  determine  if  an  arbitrary  program  with arbitrary input will terminate? 

%Will a given program on any input always terminate? Be careful here.

%Turing  proved  that  the  halting  problem  is  undecidable,  because: replace because with in other words, this means that ... make it less formal. 

%As a given problem for all inputs. Make sure this is clear, and resend him another copy of this first paragraph in the near future.

%Algorithm 1 is Classical, 4 is generalization throughout the thesis.  Delete Algorithm 2, and 3 and move Algorithm 4 from section 2 to section 1, use that here.

%Algorithm 1: Collatz Conjecture Recursion. Algorithm 4: A generalization of the Collatz Conjecture Recursion. The Collatz Conjecture halts for some variants of alg. 4. Call Alg 3/4 subscript _{\text{mod}}. Text for names, italic for variables.

%Since  the  Collatz  Conjecture  seems  to  be  quite  difficult  to  prove: replace with Since  the  Collatz  Conjecture  has been challenging to prove, instead o

%This thesis also follows an attempt that Heule and Aaronson have devised to attemptto solve the Collatz Conjecture with computers: replace first attempt with an approach

% At a high level, it involves taking a completely reworked formulation: replace with reformulation.
% It is important that the central termination property is clear. This is not the case. You now describe three variants: 1) a given program on an arbitrary input; 2) a given program on any input (Collatz); and 3) a given problem with no input (Hello World). The thesis only deals with 2) so I would make sure that all the text only discusses instances of 2).
%HERE IS NEW
Computers have been successfully applied to many complex problems, such as those in finance, healthcare, and the Internet. However, computers still struggle with seemingly simple problems. Consider whether a given program on any input will always terminate. One can easily show that certain programs will always halt. For example, we can easily show a program that takes an integer input $x$, computes $y=x+1$, prints $y$, then halts, will always terminate. Nevertheless, there exist simple programs that are much harder to determine if they always terminate. Algorithm~\ref{alg:ColR} is such an example. Will this program always return 1 for any positive integer $N$, causing it to halt? This problem is a reformulation of the Collatz Conjecture. \par
\begin{algorithm} 
\caption{The Collatz Conjecture Sequence, $\Col{N}$}
\label{alg:ColR} 
\begin{algorithmic}[1]
    \If{$N \leq 1$} \Return $N$ 
    \EndIf
    \If {$N \equiv 0 \Mod{2}$} \Return $\Col{N/2}$
    \EndIf
    \State \Return $\Col{3N + 1}$ 
\end{algorithmic}
\end{algorithm}
We know from Turing that no program exists to determine if an arbitrary program with arbitrary input can halt~\cite{Turing1936}, but that does not exclude the possibility of a program that determines if specifically Algorithm~\ref{alg:ColR} halts. However, no program has been found to show that all positive integer inputs for Algorithm~\ref{alg:ColR} will halt, even though this problem can be explained to an elementary grade student. The problem has been extensively analyzed, according to surveys by Lagrias~\cite{2003mathLagrais}~\cite{2006mathLagrias}, yet no proof has been found. Further, empirical evidence suggests that the Collatz Conjecture is true. According to a website maintained by Eric Roosendahl~\cite{EricRoose}, all numbers up to $87 \cdot 2^{60}$, or about $10^{20}$, have been tried as $N$ in Algorithm~\ref{alg:ColR}, and have converged to 1. \par
Since the Collatz Conjecture has been challenging to prove, we propose another supposedly simpler variant of it. Can we prove that the code in Algorithm \ref{alg:ColSP}, where $A = \{1\}$, and $b = 8$ ($\ColMod{N}{\{1\}}{8}$ is shorthand for this problem), always terminates for any positive integer $N$? Even though this program seems to be easier, we do not have a program showing this variant always terminates either! \par
\begin{algorithm} 
\caption{A Collatz Conjecture Variant $\ColMod{N}{A}{b}$}
\label{alg:ColSP} 
\begin{algorithmic}[1]
    \If{$(N \leq 1) \vee (N \equiv a_1  \Mod{b}) \vee \ldots \vee (N \equiv a_s \Mod{b})$ } \Return $N$
    \EndIf
    \If {$N \equiv 0 \Mod{2}$} \Return $\ColMod{N/2}{A}{b}$
    \EndIf
    \State \Return $\ColMod{3N+1}{A}{b}$ 
\end{algorithmic}
\end{algorithm}
One of the goals of this Thesis is to try and determine how hard certain variants of the Collatz Conjecture are to solve. A contribution of this thesis is that it uses empirical data to try and find trends of hardness for difficult variants, and compare these trends to the hardness of solving the whole Collatz Conjecture. This thesis also follows an approach that Heule and Aaronson have devised to attempt to craft a program to determine if Algorithm~\ref{alg:ColR} always halts~\cite{HeuleAaronson}. At a high level, it involves taking a completely reworked formulation of Algorithm~\ref{alg:ColR} and using known techniques that, if certain conditions are met, the reworked formulation can be shown to terminate for any positive integer input. The formulation requires SAT solvers, string rewrite systems, and a technique called matrix interpretation, all topics which will be covered briefly in this paper as background. This thesis also investigates a rewrite system that Aaronson crafted, and we believe that, if Aaronson's system is found to terminate for all input, the Collatz Conjecture holds. We analyze properties of this rewrite system and the variants from before are investigated with this rewrite system as well.\par
The rest of this thesis is outlined as follows: Chapter~\ref{sec:defns} introduces definitions that will be used throughout the paper. Chapter~\ref{sec:alttercdns} defines several Collatz Conjecture variants, including both solvable ones and unsolved ones, including $\ColMod{N}{\{1\}}{8})$. Chapter~\ref{sec:subhrdnspred} analyzes the difficulty of these variants using algebra. Chapter ~\ref{sec:SRSandSAT} provides a brief background on SAT Solvers and String Rewrite Systems, how SAT solvers can be used to prove termination of them, describes Aaronson's rewrite system that Heule tried to use with matrix interpretation and SAT solving to prove, and the results of this approach. Finally, chapter~\ref{sec:hardnessrewriterules} investigates hardness of solving the same variants covered in chapter~\ref{sec:subhrdnspred}, but derived from Aaronson's rewrite system instead.