\chapter{SAT Solving Background} \label{sec:SATsolving}
We want to not only analyze the hardness for the Collatz Subproblems from an algebraic perspective, but from a String Rewrite System perspective too. The next two sections deal with background required for explaining the rewrite system approach using SAT solvers, which justifies the hardness measures discussed later in this paper. First, this section will talk about the background of Boolean satisfiability, Boolean constraint propagation (BCP), the power of splitting heuristics, and the cube-and-conquer paradigm. Then, section~\ref{sec:SRSandSAT} will talk about String Rewrite Systems and how SAT solvers can be used to solve termination of them.

\section{Boolean satisfiability} \label{subsec:boolSAT}
A Boolean formula $F$ is a formula that has inputs and outputs of values true ($\boldsymbol{t}$) or false ($\boldsymbol{f}$). The base of a Boolean formula is called an atom, which is either a propositional variable, or the truth values $\boldsymbol{t}$ or $\boldsymbol{f}$. Let $p$ be a propositional variable. A literal is modifying an atom to get one of two different types: $p$, the atom itself, is a positive literal, and $\Bar{p}$  is a negative literal. A truth assignment to a formula $F$ is a partial function $\tau$ that maps literals in $F$ to $\{\boldsymbol{t}, \boldsymbol{f}\}$. \par
SAT Solvers work with a very specific type of Boolean formula called \textit{Conjunctive Normal Form} (CNF). A CNF formula only uses three Boolean operators: AND ($\wedge$), OR ($\vee$) and NOT (a negative literal or $\neg$). In a CNF formula, a clause is a disjunction of literals (disjunction meaning literals are all ORed together). The whole formula is a conjunction of clauses (conjunction meaning clauses are all ANDed together). SAT solvers work with CNF formulas because all Boolean Formulas can be converted to CNF with only a polynomial size increase due to Tseitin's Transformation~\cite{Tseitin70}. \par
Given a CNF formula $F$ and truth assignment $\tau$, the following things are true:
\begin{itemize}
    \item A clause $C$ is \textit{satisfied} by $\tau$ if $\tau(l) = \boldsymbol{t}$ for some $l \in C$
    \item A clause $C$ is \textit{falsified} by $\tau$ if $\tau(l) = \boldsymbol{f}$ for all $l \in C$
    \item A formula $F$ is \textit{satisfied} by $\tau$ if $\tau(C) = \boldsymbol{t}$ for all $C \in F$
    \item A formula $F$ is \textit{falsified} by $\tau$ if $\tau(C) = \boldsymbol{f}$ for some $C \in F$
\end{itemize}
The Boolean satisfiability problem (or SAT for short) asks whether a CNF formula contains a satisfying assignment. If a formula has a satisfying assignment, then the formula is \textit{satisfiable}. Otherwise, the formula is \textit{unsatisfiable}. $k$-SAT, where $k$ is the maximum number of literals per clause, is a decision problem derived from SAT that is NP-Complete when $k > 2$, meaning that if $P \ne NP$, the worst case runtime is exponential. However, with clever heuristics, we can actually make CNF formulas run in linear time for many interesting cases. As a result, SAT solvers can solve some incredibly complex problems, such as those found in hardware verification, software verification, and combinatorics.

\section{Boolean Constraint Propogation (BCP)} \label{subsec:BCP}
For a clause $C$ in a CNF formula $F$, we say that it is in \textit{unit} if, given an assignment $\tau$, there exists a literal $l \in C$ such that $l \not\in \tau$ and $\Bar{l} \not\in \tau$, and for all other literals $l' \in C$ such that $l' \ne l$, $\Bar{l'} \in \tau$. In other words, all literals besides one in $C$ have been assigned a truth value already that don't satisfy the clause $C$. Since $F$ is falsified if even one clause is falsified, we know that $l$ must be given the truth value that satisfies $C$. So if $l \in C$, then $l = \boldsymbol t$, and if $\Bar{l} \in C$, then $l = \boldsymbol f$. 
Boolean Constraint Propagation (BCP) takes some assignment, and extends it by finding unit literals with forced assignments using what is called \textit{unit resolution}. It continues to extend the assignment until it can no longer be extended, either when $F$ is satisfied, $F$ is falsified, or no forced unit literals need be assigned. If the assignment falsifies $F$, we say that BCP derived a conflict. \par
As SAT solvers use heuristics to determine assignments (see subsection~\ref{subsec:BCP}), they use BCP as their main inference mechanism. Algorithm~\ref{alg:BCP} shows the steps that a SAT solver takes after an assignment $\tau$ has been set on a formula $F$. As shown in this algorithm, BCP continues to extend unit literals until the formula has no more unit clauses, or a conflict has been derived. 
\begin{algorithm}
\caption{$BCP(F, \tau)$}
\label{alg:BCP}
\begin{algorithmic}[1]
    \Require $F$ is set of CNF clauses, $\tau$ is an assignment of literals
    \Ensure Either a pair ($F$, $\tau$) of the modified formula, or $\bot$ if conflict derived
    \While{$F$ contains a unit clause $(l)$}
        \If{$(\Bar{l}) \in F$}
            \Return $\bot$ \Comment{Clause $\Bar{l}$ in formula, conflict derived}
        \EndIf
        \State Add $l$ to $\tau$
        \State Remove all clauses containing $l$ from set $F \backslash \{(l)\}$
        \State Remove literal $\Bar{l}$ from all clauses in $F$
    \EndWhile
    \State \Return ($F$, $\tau$)
\end{algorithmic}
\end{algorithm}

\section{The power of splitting heuristics} \label{subsec:splitheur}
For some simpler problems, using brute force and enumerating all cases is possible. However, there are some problems that have so many combinations that it would be impossible to solve on a computer. Hence, SAT solvers use heuristics aiming to exponentially reduce the search space. However, the intuition of knowing which heuristics work best for certain problems makes SAT solving challenging as a whole. To illustrate the power of splitting heuristics, let us first consider a problem with a simple answer, then we will talk about a problem with a much more complex, and famous, answer.\par
The first problem is called the Boolean Schur Triples problem, and asks whether the natural numbers $\{1, 2, \ldots \}$ can avoid being colored monochromatically red or blue in the equation $a + b = c$, such that $a < b < c$. The answer is no, because it is not possible to color the numbers $\{1, \ldots, 9\}$ monochromatically. To show this using brute force, one would have to enumerate all possible numerical combinations up to 9: $2^9 = 512$ different colorings. However, we can use the following encoding of the 9 case that forces one summation of the numbers to be monochromatic:
\begin{align*}
(x_1 \vee x_2 \vee x_3 ) &\wedge ( \overline{x}_1 \vee \overline{x}_2 \vee \overline{x}_3 ) \wedge (x_1 \vee x_3 \vee x_4 ) \wedge ( \overline{x}_1 \vee \overline{x}_3 \vee \overline{x}_4 ) \wedge \\
(x_1 \vee x_4 \vee x_5 ) &\wedge ( \overline{x}_1 \vee \overline{x}_4 \vee \overline{x}_5 ) \wedge (x_2 \vee x_3 \vee x_5 ) \wedge ( \overline{x}_2 \vee \overline{x}_3 \vee \overline{x}_5 ) \wedge \\
(x_1 \vee x_5 \vee x_6 ) &\wedge ( \overline{x}_1 \vee \overline{x}_5 \vee \overline{x}_6 ) \wedge (x_2 \vee x_4 \vee x_6 ) \wedge ( \overline{x}_2 \vee \overline{x}_4 \vee \overline{x}_6 ) \wedge \\
(x_1 \vee x_6 \vee x_7 ) &\wedge ( \overline{x}_1 \vee \overline{x}_6 \vee \overline{x}_7 ) \wedge (x_2 \vee x_5 \vee x_7 ) \wedge ( \overline{x}_2 \vee \overline{x}_5 \vee \overline{x}_7 ) \wedge \\
(x_3 \vee x_4 \vee x_7 ) &\wedge ( \overline{x}_3 \vee \overline{x}_4 \vee \overline{x}_7 ) \wedge (x_1 \vee x_7 \vee x_8 ) \wedge ( \overline{x}_1 \vee \overline{x}_7 \vee \overline{x}_8 ) \wedge \\
(x_2 \vee x_6 \vee x_8 ) &\wedge ( \overline{x}_2 \vee \overline{x}_6 \vee \overline{x}_8 ) \wedge (x_3 \vee x_5 \vee x_8 ) \wedge ( \overline{x}_3 \vee \overline{x}_5 \vee \overline{x}_8 ) \wedge \\
(x_1 \vee x_8 \vee x_9 ) &\wedge ( \overline{x}_1 \vee \overline{x}_8 \vee \overline{x}_9 ) \wedge (x_2 \vee x_7 \vee x_9 ) \wedge ( \overline{x}_2 \vee \overline{x}_7 \vee \overline{x}_9 ) \wedge \\
(x_3 \vee x_6 \vee x_9 ) &\wedge ( \overline{x}_3 \vee \overline{x}_6 \vee \overline{x}_9 ) \wedge (x_4 \vee x_5 \vee x_9 ) \wedge ( \overline{x}_4 \vee \overline{x}_5 \vee \overline{x}_9 )
\end{align*}
Variable $x_n$ represent number $n$. $x_n$ means color number $n$ red, whereas $\overline{x}_n$ denotes to color number $n$ blue. Each clause is saying any one of three numbers $a$, $b$, or $c$ where $a + b = c$ must be colored either red or blue. \par
We can use a heuristic to choose a good variable to reduce the search space by a large size. The  heuristic chooses a variable in which we have cases where we set the variable to both true and false. We can apply the Maximum Occurrences of Minimal Size (MOMS) heuristic, and reduce the number of cases from 512 to 6. On the first step, all clauses are of size 3, so we choose $x_1$ because it occurs in the most clauses. We can set $x_1$ to true. As discussed, we remove all clauses which have $x_1$, and remove all occurrence of $\overline{x}_1$ from remaining clauses. The resulting formula does not apply BCP yet, because we have no unit clauses. Now we look at MOMs and several variables are in clauses of length 2, but we apply a tiebreak: which variable are in the most clauses of length 3? The answer is $x_3$. We, hence, set that to true. Now BCP finds that $x_2$ and $x_4$ must be set to false ($1+2 = 3$ and $1+3 = 4$), which forces $x_6$ to be true ($2+4=6$), which forces $x_7$ and $x_9$ to be false ($1+6 = 7$ and $3+6 = 9$). However, $2+7=9$, and all those numbers are false, so $x_3$ can't be true. So now the SAT solver sets $x_3$ to false. This time, no more BCP can be applied. The resulting clause runs MOMs and finds that $x_5$ occurs in the most clauses with length 2. Setting this to true forces 4 and 6 to be false ($1+4 = 5$ and $1+5 = 6$), which forces 2 and 7 to be true ($2+4=6$ and $3+4=7$). However, this makes $2+5 = 7$ all true, leading to another contradiction. Switching $x_5$ to false also leads to a contradiction, and backtracking and switching $x_1$ to false also clearly leads to a contradiction, and trying to once again set $x_3$ then $x_5$ to true and false, also leading to contradictions. This is a total of 6 variable assignments, much fewer than the 512 that brute force would have enumerated. \par
For this case, MOMS was a great choice, but it is one of many heuristics. We will talk about two more examples. One is called Dynamic Largest Individual Sum (DLIS)~\cite{Silva:1999:IBH:645377.651196}, which targets literals that satisfy the most number of clauses. Going back to our example using this heuristic, we would choose either $x_1$ or $\overline{x}_1$ (both are tied) and assign the values that way. Another example is called Variable State Independent Decaying Sum (VSIDS)~\cite{Moskewicz:2001}. This heuristic favors variables that are stored in more conflict clauses, a big part of Conflict-Driven Clause Learning (CDCL), which will be covered more in subsection~\ref{subsec:cnc}. \par
The Boolean Schur Triples problem is a very simple case, but heuristics on a larger scale are much more impressive. Famously in 2016, Heule, Kullmann, and Marek solved the Pythagorean Triples Problem using SAT solving, producing a 200 TB proof, the largest ever at the time~\cite{DBLP:journals/corr/HeuleKM16}. The Pythagorean Triples Problem is like the Boolean Schurs problem, but instead asks it is possible to avoid a monochromatic coloring of three natural numbers such that $a^2+b^2 = c^2$. The answer determined was that it is possible up to 7824, but not possible for 7825. To confirm that the number is 7825 with just brute force, it would take $2^{7825}$ different cases, which is over $2^{7000}$ times the estimated number of particles in the universe! With heuristics, it is possible to reduce the number of cases to around a trillion $(\sim 2^{40})$, which, while still a huge amount of cases, was solvable in a few CPU years, much better than the immeasurable amount of power brute force would require.

\section{Cube-and-Conquer} \label{subsec:cnc}
Cube-and-Conquer is a SAT solving paradigm developed by Heule, Kullman, Wierigna, and Biere~\cite{HeuleKWB12} that was famously applied to the Pythagorean Triples Problem~\cite{DBLP:journals/corr/HeuleKM16}. Cube-and-Conquer splits a problem into $N$ problems using heuristics. There are two different phases to Cube-and-Conquer: The ``Cube'' phase, which partitions the problems into $N$ problems using a look-ahead solver, and the ``Conquer'' phase, which solves these problems using a CDCL (Conflict Driven Clause Learning) solver. This section will talk about each phase in a bit more detail. 

\subsection{``Cube'' phase} \label{subsubsec:cnccube}
A ``Cube'' is a conjunction of literals. It can be disjuncted with several other cubes, creating a formula in DNF. If one of the cubes is satisfied, then the DNF formula is satisfied. \par
Such is the underlying notion of the ``Cube'' phase of Cube and Conquer. A lookahead solver uses the David-Putnam-Logemann-Loveland (DPLL) algorithm~\cite{Davis:1962:MPT:368273.368557}. The DPLL algorithm assigns a literal $x_1 = \boldsymbol t$ then applies BCP until a conflict is derived, or another literal needs to be assigned a value. Lookahead solvers use the assignment of a literal to a formula $F$, apply BCP if needed, then derive a new formula $F'$, then finally, it measures the difference between $F$ and $F'$ to determine if $x_1$ was a good variable choice.  Then, given $n$ literal selections, the cube $C = x_1 \wedge x_2 \cdots \wedge x_n$ is built. If a conflict is derived when solving $C$, then we know the negation of this cube, $\overline{C}$, must be true. The negation of a cube can also be used as a conflict clause. \par
$N$ (valid) cubes are built, and the reduced subformulas $\{F'_1, \ldots, F'_N\}$ are hence fed to the ``Conquer'' phase. The optimal $N$ that should be built for the fastest runtime varies from problem to problem, and is in essence a decision heuristic of its own.

 \subsection{``Conquer'' phase} \label{subsubsec:cncconquer}
 A CDCL SAT Solver learns conflict clauses by deriving conflicts from BCP. For instance, if $x_1 = \boldsymbol t$, $x_2 = \boldsymbol f$, and $x_3 = \boldsymbol f$ leads to a conflict in $F$, then CDCL derives a conflict clause of $\overline{(x_1 \wedge \overline{x_2} \wedge \overline{x_3})} = (\overline{x_1} \vee x_2 \vee x_3)$ by DeMorgan's Law. Since this conflict clause must hold true for the overall CNF formula, we can append it to the CNF formula we are trying to solve, and prevent the SAT solver from straying towards incorrect variable selections again, reducing runtime. \par
 Combined with the ``Cube'' phase, in some cases, the $N$ subformulas created by the cubes can be refuted (or satisfied) much quicker than if the whole formula were to try and be solved using CDCL. Further, the subformulas can be parallelized quite easily to many different computers, making Cube and Conquer an attractive option for use with multicore computers.