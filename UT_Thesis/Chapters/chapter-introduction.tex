\chapter{Introduction} \label{sec:introduction}
%Introduction: First sentence: Computers have been very powerful applications for many things, but they don't work for seemingingly simple problems.

%Second sentence: Does  there  exist  a  program  that  can  determine  if  an  arbitrary  program  with arbitrary input will terminate? 

%Will a given program on any input always terminate? Be careful here.

%Turing  proved  that  the  halting  problem  is  undecidable,  because: replace because with in other words, this means that ... make it less formal. 

%As a given problem for all inputs. Make sure this is clear, and resend him another copy of this first paragraph in the near future.

%Algorithm 1 is Classical, 4 is generalization throughout the thesis.  Delete Algorithm 2, and 3 and move Algorithm 4 from section 2 to section 1, use that here.

%Algorithm 1: Collatz Conjecture Recursion. Algorithm 4: A generalization of the Collatz Conjecture Recursion. The Collatz Conjecture halts for some variants of alg. 4. Call Alg 3/4 subscript _{\text{mod}}. Text for names, italic for variables.

%Since  the  Collatz  Conjecture  seems  to  be  quite  difficult  to  prove: replace with Since  the  Collatz  Conjecture  has been challenging to prove, instead o

%This thesis also follows an attempt that Heule and Aaronson have devised to attemptto solve the Collatz Conjecture with computers: replace first attempt with an approach

% At a high level, it involves taking a completely reworked formulation: replace with reformulation.
%HERE IS NEW
Computers have been successfully applied to many complex problems, such as those in finance, healthcare, and the Internet. However, computers still struggle with seemingly simple problems. \par
Consider whether a given program on arbitrary input will always terminate. One can easily show that certain programs will always halt. For example, a program that only prints ``Hello World!'' then exits will always terminate. Nevertheless, there exist simple programs that are much harder to determine if they always terminate. Algorithm~\ref{alg:ColR} is such an example. Will this program always return 1 for any positive integer $N$, causing it to halt? This problem is a reformulation of the Collatz Conjecture. \par
\begin{algorithm} 
\caption{The Collatz Conjecture Sequence, $\Col{N}$}
\label{alg:ColR} 
\begin{algorithmic}[1]
    \If{$N \leq 1$} \Return $N$ 
    \EndIf
    \If {$N \equiv 0 \Mod{2}$} \Return $\Col{N/2}$
    \EndIf
    \State \Return $\Col{3N + 1}$ 
\end{algorithmic}
\end{algorithm}
We know from Turing that no program exists to determine if an arbitrary program with arbitrary input can halt~\cite{Turing1936}, but that does not exclude the possibility of a program that determines if specifically Algorithm~\ref{alg:ColR} halts. However, no program has been found to show that all inputs for Algorithm~\ref{alg:ColR} will halt, even though this problem can be explained to an elementary grade student. Many approaches have been tried since 1963~\cite{2003mathLagrais}~\cite{2006mathLagrias}. Further, empirical evidence suggests that the Collatz Conjecture is true: according to a website maintained by Eric Roosendahl~\cite{EricRoose}, all numbers up to $87 \cdot 2^{60}$, or about $10^{20}$, have been tried as $N$ in Algorithm~\ref{alg:ColR}, and have converged to 1. \par
Since the Collatz Conjecture has been challenging to prove, we propose another supposedly simpler variant of it. Can we prove that the code in Algorithm \ref{alg:ColSP}, where $A = \{1\}$, and $b = 8$ ($\ColMod{N}{\{1\}}{8}$ is shorthand for this problem), always terminates for any input number? Even though this program seems to be easier, we do not have a program showing this variant always terminates either! \par
\begin{algorithm} 
\caption{A Collatz Conjecture Variant $\ColMod{N}{A}{b}$}
\label{alg:ColSP} 
\begin{algorithmic}[1]
    \If{$(N \leq 1) \vee (N \equiv a_1  \Mod{b}) \vee \ldots \vee (N \equiv a_s \Mod{b})$ } \Return $N$
    \EndIf
    \If {$N \equiv 0 \Mod{2}$} \Return $\ColMod{N/2}{A}{b}$
    \EndIf
    \State \Return $\ColMod{3N+1}{A}{b}$ 
\end{algorithmic}
\end{algorithm}
One of the goals of this Thesis is to try and determine how hard certain variants of the Collatz Conjecture are to solve. A contribution of this thesis is that it uses empirical data to try and find trends of hardness for difficult variants, and compare these trends to the hardness of solving the whole Collatz Conjecture. This thesis also follows an approach that Heule and Aaronson have devised to attempt to craft a program to determine if Algorithm~\ref{alg:ColR} always halts~\cite{HeuleAaronson}. At a high level, it involves taking a completely reworked formulation of Algorithm~\ref{alg:ColR} and using known techniques that, if certain conditions are met, the reworked formulation can be shown to terminate for any input. The formulation requires SAT solvers, string rewrite systems, and a technique called matrix interpretation, all topics which will be covered brierfly in this paper as background. An investigation on the difficulty of solving Algorithm~\ref{alg:ColSP} for certain values of $A$ and $b$ using a rewrite system that represents the Collatz Conjecture instead of algebra is another contribution by this thesis.\par
The rest of this thesis is outlined as follows: Chapter~\ref{sec:defns} introduces definitions that will be used throughout the paper. Chapter~\ref{sec:alttercdns} defines several Collatz Conjecture variants, including both solvable ones and unsolved ones, including $\ColMod{N}{\{1\}}{8})$. Chapter~\ref{sec:subhrdnspred} analyzes the difficulty of these variants using algebra. Chapter~\ref{sec:SRSandSAT} provides background on String Rewrite Systems, and how SAT solvers can be used to prove termination of them. Chapter~\ref{sec:CollatzSRS} talks about Aaronson's rewrite system that Heule tried to use with matrix interpretation and SAT solving to prove, and chapter~\ref{sec:provingCollatzresults} presents the results of this approach. Finally, chapter~\ref{sec:hardnessrewriterules} investigates hardness of solving the same variants covered in chapter~\ref{sec:subhrdnspred}, but derived from Aaronson's rewrite system instead.
 %From here, link towards the many approaches that are documented by Lagrias over most of the last 50 years. I don't think the Halting problem is relevant in the introduction anymore, so don't force it.
%At this point, mention the variant.


%BELOW IS OLD.
%Computers, while ubiquitous in everyday life, are not all-powerful. Consider this question, for instance: \textit{Does there exist a program that can determine if an arbitrary program with arbitrary input will terminate?} This is called the halting problem, and Turing in 1936 found that no program can determine if arbitrary code with arbitrary input can exist.~\cite{Turing1936}. More formally, Turing proved that the halting problem is undecidable, because if we turn the halting problem into a decision problem (a yes/no question), we cannot decide the answer.\par
%The halting problem not only had an impact on computer science, but on mathematics as well. An example is the unsolved Collatz Conjecture. The conjecture states that all positive numbers that follow the sequence depicted in Algorithm \ref{alg:ColR} will eventually reach 1. (An iterative version is provided by Algorithm \ref{alg:ColI}).
%\begin{algorithm} 
%\caption{The Collatz Conjecture Sequence, $Col(N)$ (Recursive)}
%\label{alg:ColR} 
%\begin{algorithmic}[1]
%    \If{$N \leq 1$} \Return $N$ 
%    \EndIf
%    \If {$N \equiv 0 \Mod{2}$} \Return $Col(N/2)$
%    \EndIf
%    \State \Return $Col(3N + 1)$ 
%\end{algorithmic}
%\end{algorithm}
%\begin{algorithm} 
%\caption{The Collatz Conjecture Sequence, $Col(N)$ (Iterative)}
%\label{alg:ColI} 
%\begin{algorithmic}[1]
%    \While{$N > 1$} 
%    \If {$N \equiv 0 \Mod{2}$} $N = N/2$
%        \Else \text{ $N = 3N + 1)$}
%        \EndIf
%    \EndWhile
%\end{algorithmic}
%\end{algorithm}

%Algorithm 1 belongs to a class of undecidable problems, as was shown by Conway in 1972~\cite{Conway72} in a paper showing that a generalization of all problems like the Collatz Conjecture be reduced to the halting problem.\footnote{For more detail, see~\cite{2003mathLagrais}, p. 19.}\par
%While the Collatz Conjecture belongs to a class of undecidable problems, this does not mean that the Collatz Conjecture itself is unprovable. However, it seems quite challenging: many approaches have been tried. Lagrias compiled two comprehensive surveys which encapsulate several approaches from 1963-2009~\cite{2003mathLagrais}~\cite{2006mathLagrias}. Further, according to a website maintained by Roosendaal~\cite{EricRoose}, numbers up to $87 \cdot 2^{60}$, or about $10^{20}$, have been tried as $N$ in Algorithm~\ref{alg:ColI}, and all have converged to 1. This further fuels the search for a proof or a counterexample to the Collatz Conjecture. \par
%Since the Collatz Conjecture seems to be quite difficult to prove, we propose another supposedly simpler question. Can we prove that the code in Algorithm \ref{alg:ColM} always terminates for any input number? Even though this seems easier to prove, we do not have a solution for it either! 
%\begin{algorithm} 
%\caption{A Collatz Conjecture Subproblem, $Col_{sub}(N,1,8)$}
%\label{alg:ColM} 
%\begin{algorithmic}[1]
%    \If{$(N \leq 1) \vee (N \equiv 1 \Mod{8})$ } \Return $N$
%    \EndIf
%    \If {$N \equiv 0 \Mod{2}$} \Return $Col_{sub}(N/2,1,8)$
%    \EndIf
%    \State \Return $Col_{sub}(3N + 1,1,8)$ 
%\end{algorithmic}
%\end{algorithm}
%One of the goals of this Thesis is to try and determine how hard this subproblem, and other related subproblems, are to solve. One contribution of this thesis is that it used empirical data to try and find trends of hardness for these subproblems, and compare this to the hardness of solving the whole Collatz Conjecture. \par
%This thesis also follows an attempt that Heule and Aaronson have devised to attempt to solve the Collatz Conjecture with computers~\cite{HeuleAaronson}. At a high level, it involves taking a completely reworked formulation of Algorithm \ref{alg:ColR} and using known techniques that, if certain conditions are met, the reworked formulation can be shown to terminate for any input. The formulation requires SAT solvers, string rewrite systems, and a technique called matrix interpretation, all topics which will be covered in this paper as background. An investigation on the difficulty of solving Algorithm \ref{alg:ColM} and related subproblems using the rewrite system instead of algebra is another contribution by this thesis.\par
%The rest of this paper is outlined as follows: Section~\ref{sec:defns} introduces definitions that will be used throughout the paper. Section~\ref{sec:alttercdns} defines several Collatz Conjecture subproblems, including the one based on Algorithm \ref{alg:ColM}, while section~\ref{sec:subhrdnspred} analyzes the difficulty of these subproblems, algebraically. Section~\ref{sec:SATsolving} provides background on SAT solving. Section~\ref{sec:SRSandSAT} provides background on String Rewrite System, and how SAT solvers can be used to prove termination of them. Section~\ref{sec:CollatzSRS} talks about Aaronson's rewrite system that Heule tried to use with matrix interpretation and SAT solving to prove, and section~\ref{sec:provingCollatzresults} presents the results of this approach. Finally, section~\ref{sec:hardnessrewriterules} investigates hardness of solving the same subproblems covered in section~\ref{sec:subhrdnspred}, but derived from Aaronson's rewrite system instead.
