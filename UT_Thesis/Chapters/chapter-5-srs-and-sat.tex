\chapter{Heule's and Aaronson's Attempts to Prove the Collatz Conjecture} \label{sec:SRSandSAT}
\hl{In this chapter, we touch upon the attempt that Heule and Aaronson came up with to try and prove the Collatz Conjecture. Before doing so, we mention background needed to understand the approach: SAT solvers, string rewrite systems, and matrix interpretation. We then introduce the string rewrite system that Aaronson built,} which, if it terminates, we believe it is equivalent to showing that the Collatz Conjecture holds. We then present results of attempts where Heule applied parallel SAT solving instances on Aaronson's rewrite system to see if the Collatz Conjecture holds.
\section{SAT Solver Background}
SAT solvers are powerful programs that can solve some incredibly complex problems, such as those found in hardware verification, software verification, and combinatorics. SAT solvers leverage the fact that $k$-SAT, where $k$ is the maximum number of literals per clause, is a decision problem that is NP-Complete when $k > 2$\footnote{\hl{See the Cook-Levin Theorem for a proof showing that $k$-SAT is NP-complete.}}, meaning that if $P \ne NP$, the worst case runtime is exponential. However, with clever heuristics, we can actually solve many interesting propositional logic formulas in linear time. Also, since $k$-SAT is NP-Complete, other NP-Complete problems may be reduced to it, meaning some instances of NP-Complete problems can be solved with SAT solvers. Knowing SAT solving background is not important for this thesis, but there is a great deal of literature talking about SAT solving, so one can check, for instance,~\cite{Biere:2009:HSV:1550723}.
\section{String Rewrite System and Matrix Interpretation Background}
A string rewriting system (SRS), at a high level, takes a input string of an certain alphabet (set of valid symbols) and applies string rewriting rules (SRRs) in an arbitrary order on the input string to see if the string can be transformed further. The SRS continues to apply SRRs on the input string until the input string no longer has any substrings as input for an SRR. This causes the SRS to terminate. \par
An example SRS to explain further is given.\par\noindent
\textbf{SRS A:} The alphabet is $\Sigma = \{a, b, c\}$ and the SRRs are as follows:
\begin{enumerate}
    \item $aa \rightarrow bc$
    \item $bb \rightarrow ac$
    \item $cc \rightarrow ab$
\end{enumerate}
A problem, called Zantema's Other Problem~\cite{Hofbauer:2006:TA:1142725.1711178}, using SRS A, asks the following question:\par\noindent
\textbf{Zantema's Other Problem:}
Does the system laid out in SRS $A$ terminate for any input string $(a|b|c)*$?\par
If one thinks about this problem a little, it would seem that a proof should be easy to show.  Surprisingly, both humans and computers struggled to come up with a proof for this problem when initially presented.  However, Hofbauer and Waldmann came up with a proof~\cite{Hofbauer:2006:TA:1142725.1711178}, and from this \hl{found that, if the alphabet of an SRS can be converted to functions with certain properties, we can prove that any input string to this SRS can terminate}~\cite{Hofbauer2006}. 

\par
\hl{We explain in more detail using Zantema's other problem. The matrices needed, which are from} ~\cite{Hofbauer:2006:TA:1142725.1711178}, are the following:
\begin{align*}
a(\Vec{x}) &= \begin{pmatrix}
1&0&0&3\\
0&0&2&1\\
0&1&0&1\\
0&0&0&0
\end{pmatrix} \Vec{x} + \begin{pmatrix}
1\\
0\\
1\\
0
\end{pmatrix}\\
b(\Vec{x}) &= \begin{pmatrix}
1&2&0&0\\
0&2&0&1\\
0&1&0&0\\
0&0&0&0
\end{pmatrix} \Vec{x} + \begin{pmatrix}
1\\
2\\
0\\
0
\end{pmatrix}\\
c(\Vec{x}) &= \begin{pmatrix}
1&0&0&1\\
0&0&0&1\\
0&1&0&1\\
0&2&0&0
\end{pmatrix} \Vec{x} + \begin{pmatrix}
1\\
0\\
3\\
0
\end{pmatrix}
\end{align*}
\hl{We can build a vector representation of an input string by composing the functions for symbols together. For instance, if we build the vector representation of the input string ``$bbaa$,'' we would compute} $b \circ b \circ b \circ a (\Vec{0})$, \hl{which gives us the following vector:}
\[
b(b(a(a(\Vec{0}))))= \begin{pmatrix}
18\\14\\6\\0 \end{pmatrix}
\]
\hl{The matrices chosen earlier are not constructed arbitrarily. They are chosen in such a manner that, any time an input string has a rewrite rule applied to it, the magnitude of the vector representation of the input string decreases. The vector must continue to decrease in magnitude until the input string can no longer accept new SRRs, causing the SRS to terminate. The search for correct matrices is challenging, but SAT solvers can help in this process by checking if a $d \times d$ matrix is large enough to meet the aforementioned requirements. The process of building these matrices is technical so further background will not be covered here, but if one is interested, they can check} the paper by Endrullis, Waldmann and Zantema~\cite{Endrullis2006}.
  % found that, for any rewriting rules in any rewrite system, if they are transformed into functions that causes all inputs to decrease, then the rewrite system will terminate.~\cite{Hofbauer2006}. \par
%These functions are typically built with matrices. A SAT solver can check if a $d \times d$ matrix is large enough to ensure that the matrix functions for the set of rewrite rules always decrease for all inputs. The process of building these matrices is described in a paper by Endrullis, Waldmann and Zantema~\cite{Endrullis2006}. An example using Zantema's Other Problem will be explained here. 
We will use our example string ``$bbaa$'' to show that the vector representation of it is always decreasing, but first, define the $\succ$ operator to show that, for vectors $(x_1 \ldots x_d)$ and $(y_1 \ldots y_d)$, $(x_1 \ldots x_d) \succ (y_1 \ldots y_d)$ if $x_1 > y_1$ and $x_i \geq y_i$ for $i \in \{2, \ldots, d\}$. In other words, the first element of a vector must be always decreasing after we apply a rule, while the other $d-1$ elements must either be the same number or decrease. \hl{This operator ensures the magnitude of the vector always decreases.} \par
The following is a possible set of rules that can be applied to ``$bbaa$'' as well as the vector representations of the string: \par
%Made text small to have it all fit in one line.
{\small
\begin{alignat*}{10}
    &bb\underline{aa}\  &&\rightarrow\  b\underline{bb}c\  &&\rightarrow\  ba\underline{cc}\  &&\rightarrow\  b\underline{aa}b\  &&\rightarrow\  \underline{bb}cb\  &&\rightarrow\  a\underline{cc}b\  &&\rightarrow\  aa\underline{bb}\  &&\rightarrow\  a\underline{aa}c\  &&\rightarrow\  ab\underline{cc}\  &&\rightarrow\  abab\\
    &\begin{pmatrix}18\\14\\6\\0\end{pmatrix} &&\succ
    \begin{pmatrix}17\\14\\6\\0\end{pmatrix} &&\succ
    \begin{pmatrix}15\\14\\6\\0\end{pmatrix} &&\succ
    \begin{pmatrix}14\\14\\6\\0\end{pmatrix} &&\succ
    \begin{pmatrix}13\\14\\6\\0\end{pmatrix} &&\succ
    \begin{pmatrix}7\\14\\5\\0\end{pmatrix} &&\succ
    \begin{pmatrix}6\\14\\5\\0\end{pmatrix} &&\succ
    \begin{pmatrix}4\\14\\3\\0\end{pmatrix} &&\succ
    \begin{pmatrix}3\\0\\3\\0\end{pmatrix} &&\succ
    \begin{pmatrix}2\\0\\3\\0\end{pmatrix}
\end{alignat*}
}%x 
\par
The vector representation of the strings are always decreasing as defined by the $\succ$ operator. We could apply any string with symbols $a$, $b$, and $c$ and apply rules until termination and the vectors representing the strings would always decrease.
\section{The Collatz Conjecture as a String Rewriting System} \label{subsec:CollatzSRS}
Aaronson built an SRS representing the $3N+1$ mapping~\cite{HeuleAaronson}. We'll call this the Collatz SRS throughout the remainder of this thesis. \par
Let the alphabet of the Collatz SRS consist of the symbols $a, b, c, d, e, f, g$. The symbols can be written as these linear functions:
\begin{align*}
  a(x) &= 2x & e(x) &= 3x \\
  b(x) &= 2x+1 & f(x) &= 3x+1 \\
  c(x) &= 1 & g(x) &= 3x+2 \\
  d(x) &= x & & 
\end{align*}

%the binary symbols and ternary symbols part is a bit awkward, but decided to come back to it later.
The symbols $a$ and $b$ are binary symbols. They represent  a binary system: $a$ is 0 and $b$ is 1.  The symbols $e$, $f$, and $g$ are ternary symbols. They represent a ternary system: $e$ is 0, $f$ is 1, and $g$ is 2. $c$ and $d$ are placeholder symbols to represent the leading 1 and the end of the string, respectively. They help this SRS know where the beginning and end of the string are. \par
Note that in order to correctly compute the values that the strings represent using the above linear functions, one needs to read the functions from left to right. That is to say, the string $cabad$, which is equal to 10, is not equal to $ c \circ a \circ b \circ a \circ d$, where $\circ$ is the composition of functions. Instead, $cabad = d \circ a \circ b \circ a \circ c$. Aaronson chose to write the strings like this since they follow the way we would write numbers. \par
Using the provided alphabet, Aaronson created the following series of SRRs:
\begin{alignat*}{8}
    &D_1 : ad &&\rightarrow d\ \ && \ \ A_1 : ae &&\rightarrow ea\ \ && \ \ B_1 : be &&\rightarrow fb\ \ && \ \ C_1 : ce &&\rightarrow cb \\
    &D_2 : bd &&\rightarrow gd\ \ && \ \ A_2 : af &&\rightarrow eb\ \ && \ \ B_2 : bf &&\rightarrow ga\ \ && \ \ C_2 : cf &&\rightarrow caa \\
    &\ \ && \ \ && \ \  A_3 : ag &&\rightarrow fa\ \ && \ \  B_3 : bg &&\rightarrow gb\ \ && \ \ C_3 : cg &&\rightarrow cab
\end{alignat*}
The SRRs provided here allow for Aaronson's SRS to be equivalent to the $3N+1$ mapping, but a formal proof showing this is the case is difficult, because we have yet to find a proof showing that the SRRs can be applied in arbitrary order. However, we can explain how the rules work, and show that any valid input string correctly follows the $3N+1$ mapping that the number the string represents follows, and after this, we will show the ordering we follow for the remainder of this thesis, and why this ordering is correct. \par
Each of the rules denotes how to handle the symbols $a-g$ and various combinations of them that occur. The $D$ rules represent handling the $3N+1$ mapping for a binary system. $D_1$ is how we handle an even number. It computes division of $N$ by 2 by removing the $a$ symbol that represents a binary 0. $D_2$ is actually a combination of several steps. If we were to represent $3N+1$, we could just write $bd \rightarrow bfd$, meaning take all previous symbols and multiply the result by 3 and add 1. The problem with this rule is that it increases the size of the resulting string, making the system more difficult to prove. However, $bfd \rightarrow gad$ is a valid rule,  as $d \circ f \circ b = 3(2x+1)+1 = 6x+4$ and $d \circ a \circ g = 2(3x+2) = 6x+4$, and from here, we can apply the rule $ad \rightarrow d$ to allow us to turn $gad$ into $gd$. Since $3N+1$ always results in an even number, we can just make rule $D_2$ compute $(3N+1)/2$ without growing the string size, ultimately making rule $D_2$ into $bd \rightarrow gd$. $D_2$ is the rule that makes termination of our system hard to prove. Without it, we would not need the $A$, $B$, or $C$ rules.\par
The $A$, $B$ and $C$ rules all deal with the handling of the ternary symbols and the eventual conversion of these ternary symbols into binary symbols. The $A$ and $B$ rules deal with the case when a ternary symbol is to the right of the binary symbol, and how to switch the ternary symbol and the binary symbol without changing the number the string represents. We will show that all 6 of these rules preserve the same number by showing that the string represents the same value after each rule has been applied:
\begin{itemize}
    \item $\boldsymbol{ae \rightarrow ea}$: $ae = e \circ a = e(a(x)) = 2(3x) = 6x$, and $ea = a
    \circ e = a(e(x)) = 3(2x) = 6x$.
    \item $\boldsymbol{af \rightarrow eb}$: $af = f \circ a = f(a(x)) = 3(2x)+1 = 6x+1$, and $eb =
    b \circ e = b(e(x)) = 2(3x)+1 = 6x+1$.
    \item $\boldsymbol{ag \rightarrow fa}$: $ag = g \circ a = g(a(x)) = 3(2x)+2 = 6x+2$, and $fa = a \circ f = a(f(x)) = 2(3x+1) = 6x+2$.
    \item $\boldsymbol{be \rightarrow fb}$: $be = e \circ b = e(b(x)) = 3(2x+1) = 6x+3$, and $fb = b \circ f = b(f(x)) = 2(3x+1)+1 = 6x+3$.
    \item $\boldsymbol{bf \rightarrow ga}$: $bf = f \circ b = f(b(x)) = 3(2x+1)+1 = 6x+4$, and $ga =  a \circ g = a(g(x)) = 2(3x+2) = 6x+4$.
    \item $\boldsymbol{bg \rightarrow gb}$: $bg = g \circ b = g(b(x)) = 3(2x+1)+2 = 6x+5$, and $gb = b \circ g = b(g(x)) = 2(3x+2)+1 = 6x+5$.
\end{itemize}
Hence, these rules are all correct. \par
The $C$ rules take advantage of the fact that the $c$ symbol is a binary 1, and, in a strictly binary string, it is the most significant bit of the number the string corresponds to. When the ternary symbol is adjacent to the $c$ symbol, we apply one of the three $c$ rules to convert the ternary symbol into binary symbol(s). These rules also preserve the number the string represents, shown here:
\begin{itemize}
    \item $\boldsymbol{ce \rightarrow cb}$: $ce = e \circ c = e(c(x)) = 3(1) = 3$, and $cb = b
    \circ c = b(c(x)) = 2(1)+1 = 3$.
    \item $\boldsymbol{cf \rightarrow caa}$: $cf = f \circ c = f(c) = 3(1)+ 1 = 4$, and $caa = a \circ a \circ c = a(a(c(x))) = 2(2(1)) = 4$.
    \item $\boldsymbol{cg \rightarrow cab}$: $cg = g \circ c = g(c) = 3(1)+ 2 = 5$, and $cab = b \circ a \circ c = b(a(c(x))) = 2(2(1))+1 = 5$.
\end{itemize}
Hence, we have shown that the $A$, $B$, and $C$ rules all preserve value, and the $D$ rules correctly apply the $3N+1$ mapping. \par
Here is how one can run the SRS and preserve an ordering we know to be valid:
\begin{enumerate}
    \item Take the initial input number, and convert it to binary. Make the leading 1 a $c$ symbol, and all 0's and other 1's $a$'s and $b$'s, respectively.
    \item Append a $d$ to the end of the string.
    \item Until we have the string $cd$: 
    \begin{itemize}
        \item Apply the appropriate $D$ rule.
        \item If a ternary character is generated, apply $A$ and $B$ rules until the ternary symbol and the $c$ are adjacent, then apply the appropriate $C$ rule.
    \end{itemize}
\end{enumerate}
This order of applying the SRRs is correct, because one takes a string that is strictly in binary symbols and applies the correct $D$ rules until a ternary character is generated. In this SRS, the only $D$ rule that generates a ternary character is rule $D_2$. When a ternary symbol is generated, we immediately apply $A$, $B$, and $C$ rules until the ternary symbol is converted into binary symbol(s). The number is not changed during application of the $A$, $B$, and $C$ rules, making the ordering correct. We use this to investigate properties of the Collatz SRS, which we will discuss in Chapter~\ref{sec:hardnessrewriterules}. \par
If we take the Collatz SRS and find matrix functions for all symbols that cause all vector representations of input strings to decrease when SRRs are applied, then we believe we can prove the Collatz Conjecture. \hl{We don't have a formal proof, because we don't have a proof that applying the Collatz SRRs in arbitrary order results in the same output string.} However, we strongly believe that termination of the Collatz SRS implies termination of Algorithm~\ref{alg:ColR}, since the rewrite system operates on input strings the same way as Algorithm~\ref{alg:ColR} would on positive integers.
\section{Proving Collatz Conjecture Results} \label{subsec:provingCollatzresults}
This section discusses some of the results mentioned in~\cite{HeuleAaronson}. Heule initially tried to run the Collatz SRS on state-of-the-art matrix interpretation solvers like AProVE~\cite{Giesletal:2004}. However, 4 of the 11 rules needed to be removed before the system could be solved. As a result, a custom matrix interpretation solver was built by Heule specifically for this problem. Heule, as of now, has been unable to prove termination of the entire 11 rule system with matrix interpretation. However, any combination of 10 of the 11 rules has been proven. \par
Heule has also run the matrix interpretation on several Collatz Variants: the ones that remain unproven in this thesis also have not been proved by the system yet. Hence, the motivation for investigating hardness of unproven Collatz Variants came about, as did the motivation for writing this thesis. Further work on this and related problems will be done under NSF grant CCF-1813993 in the coming years~\cite{HeuleAaronson}.

%%  LocalWords:  Heule's combinatorics Levin runtime SRS SRRs SRR aa
%%  LocalWords:  substrings bc bb Zantema's Hofbauer Waldmann bbaa ba
%%  LocalWords:  Endrullis Zantema cb abab cabad ae fb ce bd gd af eb
%%  LocalWords:  ga caa ag bg gb bfd cd AProVE CCF
